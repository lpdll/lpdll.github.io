<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>什么情况下mysql innodb会发生回表操作</title>
      <link href="2022/03/20/mysql/%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8Bmysql%20innodb%E4%BC%9A%E5%8F%91%E7%94%9F%E5%9B%9E%E8%A1%A8%E6%93%8D%E4%BD%9C/"/>
      <url>2022/03/20/mysql/%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8Bmysql%20innodb%E4%BC%9A%E5%8F%91%E7%94%9F%E5%9B%9E%E8%A1%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="什么情况下mysql-innodb会发生回表操作"><a href="#什么情况下mysql-innodb会发生回表操作" class="headerlink" title="什么情况下mysql innodb会发生回表操作"></a>什么情况下mysql innodb会发生回表操作</h3><p>MySQL innodb的主键索引是簇集索引，也就是索引的叶子节点存的是整个单条记录的所有字段值，不是主键索引的就是非簇集索引，非簇集索引的叶子节点存的是主键字段的值。</p><h4 id="回表是什么意思？"><a href="#回表是什么意思？" class="headerlink" title="回表是什么意思？"></a>回表是什么意思？</h4><p>就是你执行一条sql语句，需要从两个b+索引中去取数据。举个例子：</p><p>表tbl有a,b,c三个字段，其中a是主键，b上建了索引，然后编写sql语句</p><p>SELECT * FROM tbl WHERE a=1</p><p>这样不会产生回表，因为所有的数据在a的索引树中均能找到</p><p>SELECT * FROM tbl WHERE b=1</p><p>这样就会产生回表，因为where条件是b字段，那么会去b的索引树里查找数据，但b的索引里面只有a,b两个字段的值，没有c，那么这个查询为了取到c字段，就要取出主键a的值，然后去a的索引树去找c字段的数据。查了两个索引树，这就叫回表。</p><p>索引覆盖就是查这个索引能查到你所需要的所有数据，不需要去另外的数据结构去查。其实就是不用回表。</p><h4 id="怎么避免？"><a href="#怎么避免？" class="headerlink" title="怎么避免？"></a>怎么避免？</h4><p>不是必须的字段就不要出现在SELECT里面。或者b,c建联合索引。但具体情况要具体分析，索引字段多了，存储和插入数据时的消耗会更大。这是个平衡问题。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引</title>
      <link href="2022/03/20/mysql/MySQL%E7%B4%A2%E5%BC%95/"/>
      <url>2022/03/20/mysql/MySQL%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h3><p>MYSQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构，所以说索引的本质是：数据结构</p><p>索引的目的在于提高查询效率，可以类比字典、 火车站的车次表、图书的目录等 。</p><p>可以简单的理解为“排好序的快速查找数据结构”，数据本身之外，数据库还维护者一个满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><ul><li>索引本身也很大，不可能全部存储在内存中，一般以索引文件的形式存储在磁盘上</li><li>平常说的索引，没有特别指明的话，就是B+树（多路搜索树，不一定是二叉树）结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。此外还有哈希索引等。</li></ul><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>提高数据检索效率，降低数据库IO成本</li><li>降低数据排序的成本，降低CPU的消耗</li></ul><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul><li>索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存</li><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息</li></ul><h3 id="MySQL索引分类"><a href="#MySQL索引分类" class="headerlink" title="MySQL索引分类"></a>MySQL索引分类</h3><h4 id="数据结构角度"><a href="#数据结构角度" class="headerlink" title="数据结构角度"></a>数据结构角度</h4><ul><li>B+树索引</li><li>Hash索引</li><li>Full-Text全文索引</li><li>R-Tree索引</li></ul><h4 id="从物理存储角度"><a href="#从物理存储角度" class="headerlink" title="从物理存储角度"></a>从物理存储角度</h4><ul><li>聚集索引（clustered index）</li><li>非聚集索引（non-clustered index），也叫辅助索引（secondary index） 聚集索引和非聚集索引都是B+树结构</li></ul><h4 id="从逻辑角度"><a href="#从逻辑角度" class="headerlink" title="从逻辑角度"></a>从逻辑角度</h4><ul><li>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</li><li>普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引</li><li>多列索引（复合索引、联合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</li><li>唯一索引或者非唯一索引</li><li>空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建。</li></ul><h3 id="MySQL索引结构"><a href="#MySQL索引结构" class="headerlink" title="MySQL索引结构"></a>MySQL索引结构</h3><p>首先要明白<b>索引（index）是在存储引擎（storage engine）层面实现的，而不是server层面</b>。不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别。</p><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p>B-Tree是为磁盘等外存储设备设计的一种平衡查找树。</p><p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p><p>InnoDB 存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为16KB，可通过参数 innodb_ page_ size 将页的大小设置为 4K、8K、16K，在 MySQL 中可通过如下命令查看页的大小：show variables like ‘innodb_ page_ size’;</p><p>而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</p><p>B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述 B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</p><p>一棵m阶的B-Tree有如下条件：</p><ul><li>每个节点最多有m个孩子</li><li>除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。</li><li>若根节点不是叶子节点，则至少有2个孩子</li><li>所有叶子节点都在同一层，且不包含其它关键字信息</li><li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）</li><li>关键字的个数n满足：ceil(m/2)-1 &lt;= n &lt;= m-1</li><li>ki(i=1,…n)为关键字，且关键字升序排序</li><li>Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</li></ul><p>B-Tree 特性</p><ul><li>关键字集合分布在整颗树中；</li><li>任何一个关键字出现且只出现在一个结点中；</li><li>搜索有可能在非叶子结点结束；</li><li>其搜索性能等价于在关键字全集内做一次二分查找；</li><li>自动层次控制；</li></ul><p>B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：</p><p><img src="https://pic3.zhimg.com/80/v2-bf07856ffbdfe61816d1ecdd4ec583a6_1440w.jpg" alt="3阶B-Tree"></p><p>B-Tree的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的子结点；重复，直到所对应的子指针为空，或已经是叶子结点；因此，B-Tree的查找过程是一个顺指针查找结点和在结点的关键字中进行查找的交叉进行的过程。</p><p>模拟查找关键字29的过程：</p><ol><li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】</li><li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li><li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li><li>比较关键字29在区间（26,30），找到磁盘块3的指针P2</li><li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li><li>在磁盘块8中的关键字列表中找到关键字29。</li></ol><p>分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。</p><p>B-Tree 插入</p><p>B-Tree 是从空树起，逐个插入关键码而生成的。</p><p>在B-树，每个非失败结点的关键码个数都在[ m/2 -1, m-1]之间。插入在某个叶结点开始。如果在关键码插入后结点中的关键码个数超出了上界 m-1，则结点需要“分裂”，否则可以直接插入。</p><p>实现结点“分裂”的原则是：<br>设结点 A 中已经有 m-1 个关键码，当再插入一个关键码后结点中的状态为( m, A0, K1, A1, K2, A2, ……, Km, Am)其中 Ki &lt; Ki+1, 1 =&lt; m<br>这时必须把结点 p 分裂成两个结点 p 和 q，<br>它们包含的信息分别为：</p><ul><li>结点 p：( m/2 -1, A0, K1, A1, ……, Km/2 -1, Am/2 -1)</li><li>结点 q：(m - m/2, Am/2, Km/2+1, Am/2+1, ……, Km, Am)</li><li>位于中间的关键码 Km/2 与指向新结点 q 的指针形成一个二元组 ( Km/2, q )，插入到这两个结点的双亲结点中去。</li></ul><h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB 存储引擎就是用 B+Tree 实现其索引结构。</p><p>从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。</p><p>而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。</p><p>在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p><p>B+Tree相对于B-Tree有几点不同：</p><ul><li>非叶子节点只存储键值信息；</li><li>所有叶子节点之间都有一个链指针；</li><li>数据记录都存放在叶子节点中</li></ul><p>将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：<br><img src="https://pic3.zhimg.com/80/v2-e213b1289dd51d5943d1c5305ab5b63e_1440w.jpg" alt="3阶B-Tree"></p><p>通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</p><p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为10^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。</p><p>B+Tree性质</p><ul><li>通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</li><li>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了，这个是非常重要的性质，即索引的最左匹配特性。</li></ul><blockquote><p>为什么Mysql索引要用B+树不是B树？</p><ul><li>用B+树不用B树考虑的是IO对性能的影响，B树的每个节点都存储数据，而B+树只有叶子节点才存储数据，所以查找相同数据量的情况下，B树的高度更高，IO更频繁。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。其中在MySQL底层对B+树进行进一步优化：在叶子节点中是双向链表，且在链表的头结点和尾节点也是循环指向的。<br>面试官：为何不采用Hash方式？</li><li>因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ Tree是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。</li><li>哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。</li></ul></blockquote><h3 id="索引的结构"><a href="#索引的结构" class="headerlink" title="索引的结构"></a>索引的结构</h3><h4 id="MyISAM主键索引与辅助索引的结构"><a href="#MyISAM主键索引与辅助索引的结构" class="headerlink" title="MyISAM主键索引与辅助索引的结构"></a>MyISAM主键索引与辅助索引的结构</h4><p>MyISAM引擎的索引文件和数据文件是分离的。MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址。索引文件与数据文件分离，这样的索引称为”非聚簇索引”。MyISAM的主索引与辅助索引区别并不大，只是主键索引不能有重复的关键字。</p><p><img src="https://pic3.zhimg.com/80/v2-7281aac18de64960d3b062a8c483117a_1440w.jpg" alt="3阶B-Tree"><br>在MyISAM中，索引（含叶子节点）存放在单独的.myi文件中，叶子节点存放的是数据的物理地址偏移量（通过偏移量访问就是随机访问，速度很快）。</p><p>主索引是指主键索引，键值不可能重复；辅助索引则是普通索引，键值可能重复。</p><p>通过索引查找数据的流程：先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数据文件中通过文件指针定位了具体的数据。辅助索引类似。</p><h4 id="InnoDB主键索引与辅助索引的结构"><a href="#InnoDB主键索引与辅助索引的结构" class="headerlink" title="InnoDB主键索引与辅助索引的结构"></a>InnoDB主键索引与辅助索引的结构</h4><p>InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录（对于主索引，此处会存放表中所有的数据记录；对于辅助索引此处会引用主键，检索的时候通过主键到主键索引中找到对应数据行），或者说，InnoDB的数据文件本身就是主键索引文件，这样的索引被称为”“聚簇索引”，一个表只能有一个聚簇索引。</p><h5 id="主键索引："><a href="#主键索引：" class="headerlink" title="主键索引："></a>主键索引：</h5><p>我们知道InnoDB索引是聚集索引，它的索引和数据是存入同一个.idb文件中的，因此它的索引结构是在同一个树节点中同时存放索引和数据，如下图中最底层的叶子节点有三行数据，对应于数据表中的id、stu_id、name数据项。</p><p><img src="https://pic2.zhimg.com/80/v2-7d335799db4209b7fe692bcbc991453d_1440w.jpg" alt="3阶B-Tree"></p><p>在Innodb中，索引分叶子节点和非叶子节点，非叶子节点就像新华字典的目录，单独存放在索引段中，叶子节点则是顺序排列的，在数据段中。Innodb的数据文件可以按照表来切分（只需要开启innodb_file_per_table)，切分后存放在xxx.ibd中，默认不切分，存放在xxx.ibdata中。</p><h5 id="辅助（非主键）索引："><a href="#辅助（非主键）索引：" class="headerlink" title="辅助（非主键）索引："></a>辅助（非主键）索引：</h5><p>这次我们以示例中学生表中的name列建立辅助索引，它的索引结构跟主键索引的结构有很大差别，在最底层的叶子结点有两行数据，第一行的字符串是辅助索引，按照ASCII码进行排序，第二行的整数是主键的值。这就意味着，对name列进行条件搜索，需要两个步骤：</p><ul><li>在辅助索引上检索name，到达其叶子节点获取对应的主键；</li><li>使用主键在主索引上再进行对应的检索操作</li></ul><p>这也就是所谓的“回表查询”</p><p><img src="https://pic3.zhimg.com/80/v2-c3392c098bd23a1f4a2db4063a509bb2_1440w.jpg" alt="3阶B-Tree"></p><blockquote><p>InnoDB 索引结构需要注意的点</p><ul><li>数据文件本身就是索引文件</li><li>表数据文件本身就是按 B+Tree 组织的一个索引结构文件</li><li>聚集索引中叶节点包含了完整的数据记录</li><li>InnoDB 表必须要有主键，并且推荐使用整型自增主键</li></ul></blockquote><p>正如我们上面介绍 InnoDB 存储结构，索引与数据是共同存储的，不管是主键索引还是辅助索引，在查找时都是通过先查找到索引节点才能拿到相对应的数据，如果我们在设计表结构时没有显式指定索引列的话，MySQL 会从表中选择数据不重复的列建立索引，如果没有符合的列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，并且这个字段长度为6个字节，类型为整型。</p><blockquote><p>那为什么推荐使用整型自增主键而不是选择UUID？</p><ul><li>UUID是字符串，比整型消耗更多的存储空间；</li><li>在B+树中进行查找时需要跟经过的节点值比较大小，整型数据的比较运算比字符串更快速；</li><li>自增的整型索引在磁盘中会连续存储，在读取一页数据时也是连续；UUID是随机产生的，读取的上下两行数据存储是分散的，不适合执行where id &gt; 5 &amp;&amp; id &lt; 20的条件查询语句。</li><li>在插入或删除数据时，整型自增主键会在叶子结点的末尾建立新的叶子节点，不会破坏左侧子树的结构；UUID主键很容易出现这样的情况，B+树为了维持自身的特性，有可能会进行结构的重构，消耗更多的时间。</li></ul></blockquote><blockquote><p>为什么非主键索引结构叶子节点存储的是主键值？</p></blockquote><blockquote><ul><li>保证数据一致性和节省存储空间，可以这么理解：商城系统订单表会存储一个用户ID作为关联外键，而不推荐存储完整的用户信息，因为当我们用户表中的信息（真实名称、手机号、收货地址···）修改后，不需要再次维护订单表的用户数据，同时也节省了存储空间。</li></ul></blockquote><h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><ul><li>主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。</li><li>检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。目前使用Hash索引的数据库并不多，主要有Memory等。</li><li>MySQL目前有Memory引擎和NDB引擎支持Hash索引。</li></ul><h4 id="full-text全文索引"><a href="#full-text全文索引" class="headerlink" title="full-text全文索引"></a>full-text全文索引</h4><ul><li>全文索引也是MyISAM的一种特殊索引类型，主要用于全文索引，InnoDB从MYSQL5.6版本提供对全文索引的支持。</li><li>它用于替代效率较低的LIKE模糊匹配操作，而且可以通过多字段组合的全文索引一次性全模糊匹配多个字段。</li><li>同样使用B-Tree存放索引数据，但使用的是特定的算法，将字段数据分割后再进行索引（一般每4个字节一次分割），索引文件存储的是分割前的索引字符串集合，与分割后的索引信息，对应Btree结构的节点存储的是分割后的词信息以及它在分割前的索引字符串集合中的位置。</li></ul><h5 id="使用全文索引"><a href="#使用全文索引" class="headerlink" title="使用全文索引"></a>使用全文索引</h5><h6 id="创建全文索引"><a href="#创建全文索引" class="headerlink" title="创建全文索引"></a>创建全文索引</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE article (</span><br><span class="line">    id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,</span><br><span class="line">    title VARCHAR (200),</span><br><span class="line">    body TEXT,</span><br><span class="line">    FULLTEXT (title, body) WITH PARSER ngram  ##  全文索引</span><br><span class="line">) ENGINE &#x3D; INNODB DEFAULT CHARSET&#x3D;utf8mb4 COMMENT&#x3D;&#39;文章表&#39;;</span><br></pre></td></tr></table></figure><h6 id="新增全文索引-已创建过表的情况下-使用"><a href="#新增全文索引-已创建过表的情况下-使用" class="headerlink" title="新增全文索引 (已创建过表的情况下, 使用)"></a>新增全文索引 (已创建过表的情况下, 使用)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE article ADD FULLTEXT INDEX title_body_index (title,body) WITH PARSER ngram;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>全文索引有多种模式, 下面主要是自然语言搜索模式和BOOLEAN MODE模式</p><h6 id="1-自然语言搜索模式-默认"><a href="#1-自然语言搜索模式-默认" class="headerlink" title="1. 自然语言搜索模式 (默认)"></a>1. 自然语言搜索模式 (默认)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM article WHERE MATCH (title,body) AGAINST (&#39;精神&#39; IN NATURAL LANGUAGE MODE);</span><br><span class="line">+----+-----------------+-------------------------+</span><br><span class="line">| id | title           | body                    |</span><br><span class="line">+----+-----------------+-------------------------+</span><br><span class="line">|  1 | 中国            | 中国精神                |</span><br><span class="line">+----+-----------------+-------------------------+</span><br><span class="line">SELECT * FROM article WHERE MATCH (title,body) AGAINST (&#39;精神&#39;);</span><br><span class="line">+----+-----------------+-------------------------+</span><br><span class="line">| id | title           | body                    |</span><br><span class="line">+----+-----------------+-------------------------+</span><br><span class="line">|  1 | 中国            | 中国精神                |</span><br><span class="line">+----+-----------------+-------------------------+</span><br></pre></td></tr></table></figure><p>可以看到,搜索结果命中了一条,且在不指定搜索模式的情况下,默认模式为自然语言搜索.</p><h6 id="2-BOOLEAN-MODE"><a href="#2-BOOLEAN-MODE" class="headerlink" title="2. BOOLEAN MODE"></a>2. BOOLEAN MODE</h6><p>这个模式和lucene中的BooleanQuery很像,可以通过一些操作符,来指定搜索词在结果中的包含情况.比如+表示必须包含,-表示必须不包含,默认为误操作符,代表可以出现可以不出现,但是出现时在查询结果集中的排名较高一些.也就是该结果和搜索词的相关性高一些.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM article WHERE MATCH (title,body) AGAINST (&#39;+精神&#39; IN BOOLEAN MODE);</span><br><span class="line">+----+-----------------+-------------------------+</span><br><span class="line">| id | title           | body                    |</span><br><span class="line">+----+-----------------+-------------------------+</span><br><span class="line">|  1 | 中国            | 中国精神                |</span><br><span class="line">+----+-----------------+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM article WHERE MATCH (title,body) AGAINST (&#39;+精神 -中国&#39; IN BOOLEAN MODE);</span><br><span class="line">Empty set (0.01 sec)</span><br></pre></td></tr></table></figure><p>当搜索必须命中精神时,命中了一条数据,当在加上不能包含中国的时候,无命中结果.</p><h5 id="R-Tree空间索引"><a href="#R-Tree空间索引" class="headerlink" title="R-Tree空间索引"></a>R-Tree空间索引</h5><p>空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型</p><h4 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h4><ol><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段</li><li>查询中与其他表关联的字段，外键关系建立索引</li><li>单键/组合索引的选择问题，高并发下倾向创建组合索引</li><li>查询中排序的字段，排序字段通过索引访问大幅提高排序速度</li><li>查询中统计或分组字段</li></ol><h4 id="哪些情况不要创建索引"><a href="#哪些情况不要创建索引" class="headerlink" title="哪些情况不要创建索引"></a>哪些情况不要创建索引</h4><ol><li>表记录太少</li><li>经常增删改的表</li><li>数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）</li><li>频繁更新的字段不适合创建索引（会加重IO负担）</li><li>where条件里用不到的字段不创建索引</li></ol><h3 id="MySQL高效索引"><a href="#MySQL高效索引" class="headerlink" title="MySQL高效索引"></a>MySQL高效索引</h3><p>覆盖索引（Covering Index）,或者叫索引覆盖， 也就是平时所说的不需要回表操作</p><ul><li>就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖。</li><li>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据，当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含（覆盖）满足查询结果的数据就叫做覆盖索引。</li><li>判断标准：使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为using index，MySQL查询优化器在执行查询前会决定是否有索引覆盖查询</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL一千万数据快速查询</title>
      <link href="2022/03/20/mysql/%E4%B8%80%E5%8D%83%E4%B8%87%E6%95%B0%E6%8D%AE%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2/"/>
      <url>2022/03/20/mysql/%E4%B8%80%E5%8D%83%E4%B8%87%E6%95%B0%E6%8D%AE%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="一千万数据快速查询"><a href="#一千万数据快速查询" class="headerlink" title="一千万数据快速查询"></a>一千万数据快速查询</h3><h4 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1. 创建表"></a>1. 创建表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;user_operation_log&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;user_id&#96; varchar(64) DEFAULT NULL,</span><br><span class="line">  &#96;ip&#96; varchar(20) DEFAULT NULL,</span><br><span class="line">  &#96;op_data&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;attr1&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;attr2&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;attr3&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;attr4&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;attr5&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;attr6&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;attr7&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;attr8&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;attr9&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;attr10&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;attr11&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;attr12&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;) USING BTREE,</span><br><span class="line">  KEY &#96;user_id&#96; (&#96;user_id&#96;),</span><br><span class="line">  KEY &#96;ip&#96; (&#96;ip&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;10000001 DEFAULT CHARSET&#x3D;utf8mb4 ROW_FORMAT&#x3D;DYNAMIC;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-创建数据脚本"><a href="#2-创建数据脚本" class="headerlink" title="2. 创建数据脚本"></a>2. 创建数据脚本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER ;;</span><br><span class="line">CREATE PROCEDURE batch_insert_log()</span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE i INT DEFAULT 1;</span><br><span class="line">  DECLARE userId INT DEFAULT 10000000;</span><br><span class="line"> set @execSql &#x3D; &#39;INSERT INTO &#96;test&#96;.&#96;user_operation_log&#96;(&#96;user_id&#96;, &#96;ip&#96;, &#96;op_data&#96;, &#96;attr1&#96;, &#96;attr2&#96;, &#96;attr3&#96;, &#96;attr4&#96;, &#96;attr5&#96;, &#96;attr6&#96;, &#96;attr7&#96;, &#96;attr8&#96;, &#96;attr9&#96;, &#96;attr10&#96;, &#96;attr11&#96;, &#96;attr12&#96;) VALUES&#39;;</span><br><span class="line"> set @execData &#x3D; &#39;&#39;;</span><br><span class="line">  WHILE i&lt;&#x3D;10000000 DO</span><br><span class="line">   set @attr &#x3D; &quot;&#39;测试很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的属性&#39;&quot;;</span><br><span class="line">  set @execData &#x3D; concat(@execData, &quot;(&quot;, userId + i, &quot;, &#39;10.0.69.175&#39;, &#39;用户登录操作&#39;&quot;, &quot;,&quot;, @attr, &quot;,&quot;, @attr, &quot;,&quot;, @attr, &quot;,&quot;, @attr, &quot;,&quot;, @attr, &quot;,&quot;, @attr, &quot;,&quot;, @attr, &quot;,&quot;, @attr, &quot;,&quot;, @attr, &quot;,&quot;, @attr, &quot;,&quot;, @attr, &quot;,&quot;, @attr, &quot;)&quot;);</span><br><span class="line">  if i % 1000 &#x3D; 0</span><br><span class="line">  then</span><br><span class="line">     set @stmtSql &#x3D; concat(@execSql, @execData,&quot;;&quot;);</span><br><span class="line">    prepare stmt from @stmtSql;</span><br><span class="line">    execute stmt;</span><br><span class="line">    DEALLOCATE prepare stmt;</span><br><span class="line">    commit;</span><br><span class="line">    set @execData &#x3D; &quot;&quot;;</span><br><span class="line">   else</span><br><span class="line">     set @execData &#x3D; concat(@execData, &quot;,&quot;);</span><br><span class="line">   end if;</span><br><span class="line">  SET i&#x3D;i+1;</span><br><span class="line">  END WHILE;</span><br><span class="line"> </span><br><span class="line">END;;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h4 id="3-开始测试"><a href="#3-开始测试" class="headerlink" title="3. 开始测试"></a>3. 开始测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(1) FROM &#96;user_operation_log&#96;</span><br></pre></td></tr></table></figure><p>三次查询时间分别为：</p><ul><li>14060 ms</li><li>13755 ms</li><li>13447 ms</li></ul><h4 id="4-普通分页查询"><a href="#4-普通分页查询" class="headerlink" title="4. 普通分页查询"></a>4. 普通分页查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &#96;user_operation_log&#96; LIMIT 10000, 10</span><br></pre></td></tr></table></figure><p>查询3次时间分别为：</p><ul><li>59 ms</li><li>49 ms</li><li>50 ms</li></ul><p>这样看起来速度还行，不过是本地数据库，速度自然快点。</p><p>换个角度来测试</p><h4 id="5-相同偏移量，不同数据量"><a href="#5-相同偏移量，不同数据量" class="headerlink" title="5. 相同偏移量，不同数据量"></a>5. 相同偏移量，不同数据量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &#96;user_operation_log&#96; LIMIT 10000, 10</span><br><span class="line">SELECT * FROM &#96;user_operation_log&#96; LIMIT 10000, 100</span><br><span class="line">SELECT * FROM &#96;user_operation_log&#96; LIMIT 10000, 1000</span><br><span class="line">SELECT * FROM &#96;user_operation_log&#96; LIMIT 10000, 10000</span><br><span class="line">SELECT * FROM &#96;user_operation_log&#96; LIMIT 10000, 100000</span><br><span class="line">SELECT * FROM &#96;user_operation_log&#96; LIMIT 10000, 1000000</span><br></pre></td></tr></table></figure><p>查询时间如下：</p><table><thead><tr><th>数量</th><th>第一次</th><th>第二次</th><th>第三次</th></tr></thead><tbody><tr><td>10条</td><td>53ms</td><td>52ms</td><td>47ms</td></tr><tr><td>100条</td><td>50ms</td><td>60ms</td><td>55ms</td></tr><tr><td>1000条</td><td>61ms</td><td>74ms</td><td>60ms</td></tr><tr><td>10000条</td><td>164ms</td><td>180ms</td><td>217ms</td></tr><tr><td>100000条</td><td>1609ms</td><td>1741ms</td><td>1764ms</td></tr><tr><td>1000000条</td><td>16219ms</td><td>16889ms</td><td>17081ms</td></tr></tbody></table><p>从上面结果可以得出结束：数据量越大，花费时间越长</p><h4 id="6-相同数据量，不同偏移量"><a href="#6-相同数据量，不同偏移量" class="headerlink" title="6. 相同数据量，不同偏移量"></a>6. 相同数据量，不同偏移量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &#96;user_operation_log&#96; LIMIT 100, 100</span><br><span class="line">SELECT * FROM &#96;user_operation_log&#96; LIMIT 1000, 100</span><br><span class="line">SELECT * FROM &#96;user_operation_log&#96; LIMIT 10000, 100</span><br><span class="line">SELECT * FROM &#96;user_operation_log&#96; LIMIT 100000, 100</span><br><span class="line">SELECT * FROM &#96;user_operation_log&#96; LIMIT 1000000, 100</span><br></pre></td></tr></table></figure><table><thead><tr><th>偏移量</th><th>第一次</th><th>第二次</th><th>第三次</th></tr></thead><tbody><tr><td>100</td><td>36ms</td><td>40ms</td><td>36ms</td></tr><tr><td>1000</td><td>31ms</td><td>38ms</td><td>32ms</td></tr><tr><td>10000</td><td>53ms</td><td>48ms</td><td>51ms</td></tr><tr><td>100000</td><td>622ms</td><td>576ms</td><td>627ms</td></tr><tr><td>1000000</td><td>4891ms</td><td>5076ms</td><td>4856ms</td></tr></tbody></table><p>从上面结果可以得出结束：偏移量越大，花费时间越长</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &#96;user_operation_log&#96; LIMIT 100, 100</span><br><span class="line">SELECT id, attr FROM &#96;user_operation_log&#96; LIMIT 100, 100</span><br></pre></td></tr></table></figure><h4 id="7-如何优化"><a href="#7-如何优化" class="headerlink" title="7. 如何优化"></a>7. 如何优化</h4><p>既然我们经过上面一番的折腾，也得出了结论，针对上面两个问题：偏移大、数据量大，我们分别着手优化</p><h5 id="1-优化偏移量大问题"><a href="#1-优化偏移量大问题" class="headerlink" title="1) 优化偏移量大问题"></a>1) 优化偏移量大问题</h5><h6 id="采用子查询方式"><a href="#采用子查询方式" class="headerlink" title="采用子查询方式"></a>采用子查询方式</h6><p>我们可以先定位偏移位置的 id，然后再查询数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &#96;user_operation_log&#96; LIMIT 1000000, 10</span><br><span class="line">SELECT id FROM &#96;user_operation_log&#96; LIMIT 1000000, 1</span><br><span class="line">SELECT * FROM &#96;user_operation_log&#96; WHERE id &gt;&#x3D; (SELECT id FROM &#96;user_operation_log&#96; LIMIT 1000000, 1) LIMIT 10</span><br></pre></td></tr></table></figure><p>查询结果如下：</p><table><thead><tr><th>sql</th><th>花费时间</th></tr></thead><tbody><tr><td>第一条</td><td>4818ms</td></tr><tr><td>第二条(无索引情况下)</td><td>4329ms</td></tr><tr><td>第二条(有索引情况下)</td><td>199ms</td></tr><tr><td>第三条(无索引情况下)</td><td>4319ms</td></tr><tr><td>第三条(有索引情况下)</td><td>201ms</td></tr></tbody></table><p>从上面结果得出结论：</p><ul><li>第一条花费的时间最大，第三条比第一条稍微好点</li><li>子查询使用索引速度更快</li></ul><p>缺点：只适用于id递增的情况</p><p>id非递增的情况可以使用以下写法，但这种缺点是分页查询只能放在子查询里面</p><blockquote><p>注意：某些 mysql 版本不支持在 in 子句中使用 limit，所以采用了多个嵌套select</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &#96;user_operation_log&#96; WHERE id IN (SELECT t.id FROM (SELECT id FROM &#96;user_operation_log&#96; LIMIT 1000000, 10) AS t)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="采用-id-限定方式"><a href="#采用-id-限定方式" class="headerlink" title="采用 id 限定方式"></a>采用 id 限定方式</h6><p>这种方法要求更高些，id必须是连续递增，而且还得计算id的范围，然后使用 between，sql如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &#96;user_operation_log&#96; WHERE id between 1000000 AND 1000100 LIMIT 100</span><br><span class="line">SELECT * FROM &#96;user_operation_log&#96; WHERE id &gt;&#x3D; 1000000 LIMIT 100</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查询结果如下：</p><table><thead><tr><th>sql</th><th>花费时间</th></tr></thead><tbody><tr><td>第一条</td><td>22ms</td></tr><tr><td>第二条</td><td>21ms</td></tr></tbody></table><p>从结果可以看出这种方式非常快</p><blockquote><p>注意：这里的 LIMIT 是限制了条数，没有采用偏移量</p></blockquote><h4 id="8-优化数据量大问题"><a href="#8-优化数据量大问题" class="headerlink" title="8. 优化数据量大问题"></a>8. 优化数据量大问题</h4><p>返回结果的数据量也会直接影响速度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &#96;user_operation_log&#96; LIMIT 1, 1000000</span><br><span class="line">SELECT id FROM &#96;user_operation_log&#96; LIMIT 1, 1000000</span><br><span class="line">SELECT id, user_id, ip, op_data, attr1, attr2, attr3, attr4, attr5, attr6, attr7, attr8, attr9, attr10, attr11, attr12 FROM &#96;user_operation_log&#96; LIMIT 1, 1000000</span><br></pre></td></tr></table></figure><p>查询结果如下：</p><table><thead><tr><th>sql</th><th>花费时间</th></tr></thead><tbody><tr><td>第一条</td><td>15676ms</td></tr><tr><td>第二条</td><td>7298ms</td></tr><tr><td>第三条</td><td>15960ms</td></tr></tbody></table><p>从结果可以看出减少不需要的列，查询效率也可以得到明显提升</p><p>第一条和第三条查询速度差不多，这时候你肯定会吐槽，那我还写那么多字段干啥呢，直接 * 不就完事了</p><h5 id="9-SELECT-它不香吗？"><a href="#9-SELECT-它不香吗？" class="headerlink" title="9. SELECT * 它不香吗？"></a>9. SELECT * 它不香吗？</h5><p>在这里顺便补充一下为什么要禁止 SELECT *。难道简单无脑，它不香吗？</p><p>主要两点：</p><ol><li>用 “SELECT * “ 数据库需要解析更多的对象、字段、权限、属性等相关内容，在 SQL 语句复杂，硬解析较多的情况下，会对数据库造成沉重的负担。 </li><li>增大网络开销，* 有时会误带上如log、IconMD5之类的无用且大文本字段，数据传输size会几何增涨。特别是MySQL和应用程序不在同一台机器，这种开销非常明显。</li></ol><h5 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h5><blockquote><p>作者：Owater</p><p>链接：<a href="https://juejin.cn/post/6863668253898735629">https://juejin.cn/post/6863668253898735629</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的日志种类</title>
      <link href="2022/03/08/mysql/MySQL%E7%9A%84%E6%97%A5%E5%BF%97%E7%A7%8D%E7%B1%BB/"/>
      <url>2022/03/08/mysql/MySQL%E7%9A%84%E6%97%A5%E5%BF%97%E7%A7%8D%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL的日志种类"><a href="#MySQL的日志种类" class="headerlink" title="MySQL的日志种类"></a>MySQL的日志种类</h3><ul><li>错误日志(error log)：记录出错信息，也记录一些警告信息或者正确的信息。</li><li>查询日志(General Query Log)：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。</li><li>慢查询日志(Slow Query Log)：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。</li><li>二进制日志(Binary Log)：记录对数据库执行更改的所有操作。</li><li>中继日志(reley log)：中继日志也是二进制日志，用来给slave 库恢复</li><li>事务日志(transaction  log)：重做日志redo和回滚日志undo</li></ul><h4 id="1-错误日志（error-log）"><a href="#1-错误日志（error-log）" class="headerlink" title="1. 错误日志（error log）"></a>1. 错误日志（error log）</h4><p>MySQL的错误日志用于记录MySQL服务进程mysqld在启动/关闭或运行过程中遇到的错误信息。</p><p> 错误日志路径查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;%log_error%&#39;;</span><br></pre></td></tr></table></figure><p>错误日志的记录配置</p><ul><li>在my.cnf配置文件中调整，注意，是在[mysqld_safe]或[mysqld]模块的下面进行配置。命令如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-error &#x3D; &#x2F;data&#x2F;mysql&#x2F;error.err &#x2F;data&#x2F;mysql&#x2F;error.err</span><br></pre></td></tr></table></figure><p>加完配置后需要赋予文件权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R mysql:mysql &#x2F;data&#x2F;mysql</span><br><span class="line">chmod -R 755 &#x2F;data&#x2F;mysql</span><br></pre></td></tr></table></figure><ul><li>可以在启动MySQL时，指定log_error的值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql start --log_error&#x3D;&#x2F;tmp&#x2F;DB-Server.localdomain.err</span><br></pre></td></tr></table></figure><p>该方法设置完错误日志后，关闭Mysql然后重启，你会发现log_error的值又恢复了默认。也就是说这样设置只是对本次有效，如果需要永久修改，那么就必须在my.cnf中指定log_error参数的值。</p><ul><li>错误日志归档</li></ul><p>错误日志如果不清理或删除，那么它会一直增长。在MySQL 5.5.7之前，可以通过mysqladmin –uroot –p flush-logs命令删除错误日志。MySQL 5.5.7以及之后，只能通过下面方式来归档、备份错误日志.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv host_name.err host_name.err-old</span><br><span class="line">mysqladmin -u root -p flush-logs</span><br><span class="line">mv host_name.err-old backup-directory</span><br></pre></td></tr></table></figure><h4 id="2-查询日志-General-Query-Log"><a href="#2-查询日志-General-Query-Log" class="headerlink" title="2. 查询日志(General Query Log)"></a>2. 查询日志(General Query Log)</h4><p>默认情况下，通用查询日志功能是关闭的。可以通过以下命令查看通用查询日志是否开启，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;%general%&#39;;</span><br></pre></td></tr></table></figure><p>启动和设置通用查询日志</p><p>在 MySQL 中，可以通过在 MySQL 配置文件添加 log 选项来开启通用查询日志，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">general_log &#x3D; ON</span><br></pre></td></tr></table></figure><h4 id="3-慢查询日志-Slow-Query-Log"><a href="#3-慢查询日志-Slow-Query-Log" class="headerlink" title="3. 慢查询日志(Slow Query Log)"></a>3. 慢查询日志(Slow Query Log)</h4><p>慢查询日志用来记录在 MySQL 中执行时间超过指定时间的查询语句。通过慢查询日志，可以查找出哪些查询语句的执行效率低，以便进行优化。</p><p>通俗的说，MySQL 慢查询日志是排查问题的 SQL 语句，以及检查当前 MySQL 性能的一个重要功能。如果不是调优需要，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。</p><p>查看慢查询日志是否开启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;slow_query%&#39;;</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>slow_ query_log：慢查询开启状态</li><li>slow_ query_ log_file：慢查询日志存放的位置（一般设置为 MySQL 的数据存放目录）</li></ul><p>查看慢sql执行多少秒算超时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;long_query_time&#39;;</span><br></pre></td></tr></table></figure><ul><li>long_ query_time：查询超过多少秒才记录</li></ul><p>启动和设置慢查询日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log&#x3D;ON #开启慢查询日志</span><br><span class="line">slow_query_log_file&#x3D;&#x2F;var&#x2F;log&#x2F;mysql&#x2F;slow_query.log #设置目录</span><br><span class="line">long_query_time&#x3D;1 #超时时间</span><br></pre></td></tr></table></figure><p>还可以通过以下命令启动慢查询日志、设置指定时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL slow_query_log&#x3D;ON&#x2F;OFF;</span><br><span class="line">SET GLOBAL long_query_time&#x3D;n;</span><br></pre></td></tr></table></figure><h4 id="4-二进制日志-Binary-Log"><a href="#4-二进制日志-Binary-Log" class="headerlink" title="4. 二进制日志(Binary Log)"></a>4. 二进制日志(Binary Log)</h4><p>二进制日志（Binary Log）也可叫作变更日志（Update Log），是 MySQL 中非常重要的日志。主要用于记录数据库的变化情况，即 SQL 语句的 DDL 和 DML 语句，不包含数据记录查询操作。</p><p>可以通过以下命令查看二进制日志是否开启，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;log_bin&#39;;</span><br></pre></td></tr></table></figure><p>启动和设置二进制日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log_bin&#x3D;mysql</span><br><span class="line">server-id&#x3D;101 #必须是集群中的唯一id</span><br></pre></td></tr></table></figure><blockquote><p><span style="color:red">每次重启 MySQL 服务后，都会生成一个新的二进制日志文件，这些日志文件的文件名中 filename 部分不会改变，number 会不断递增。<br></span></p></blockquote><p>查看二进制日志</p><ol><li>查看二进制日志文件列表</li></ol><p>可以使用如下命令查看 MySQL 中有哪些二进制日志文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW binary logs;</span><br></pre></td></tr></table></figure><ol start="2"><li>查看当前正在写入的二进制日志文件</li></ol><p>可以使用以下命令查看当前 MySQL 中正在写入的二进制日志文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW master status;</span><br></pre></td></tr></table></figure><ol start="3"><li>查看二进制日志文件内容</li></ol><p>二进制日志使用二进制格式存储，不能直接打开查看。如果需要查看二进制日志，必须使用 mysqlbinlog 命令。</p><p>mysqlbinlog 命令的语法形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog filename.number</span><br></pre></td></tr></table></figure><p>mysqlbinlog 命令只在当前文件夹下查找指定的二进制日志，因此需要在二进制日志所在的目录下运行该命令，否则将会找不到指定的二进制日志文件。</p><p>删除二进制日志</p><ol><li>删除所有二进制日志</li></ol><p>使用 RESET MASTER 语句可以删除的所有二进制日志，删除所有二进制日志后，MySQL 将会重新创建新的二进制日志，新二进制日志的编号从 000001 开始。</p><ol start="2"><li>根据编号删除二进制日志</li></ol><p>每个二进制日志文件后面有一个 6 位数的编号，如 000001。使用 PURGE MASTER LOGS TO 语句，可以删除指定二进制日志的编号之前的日志。该语句的基本语法形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PURGE MASTER LOGS TO &#39;filename.number&#39;;</span><br></pre></td></tr></table></figure><ol start="3"><li>根据创建时间删除二进制日志</li></ol><p>使用 PURGE MASTER LOGS TO 语句，可以删除指定时间之前创建的二进制日志，该语句的基本语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PURGE MASTER LOGS TO &#39;yyyy-mm-dd hh:MM:ss&#39;;</span><br></pre></td></tr></table></figure><p>暂时停止二进制日志</p><p>在配置文件中设置了 log_bin 选项之后，MySQL 服务器将会一直开启二进制日志功能。删除该选项后就可以停止二进制日志功能，如果需要再次启动这个功能，需要重新添加 log_bin 选项。由于这样比较麻烦，所以 MySQL 提供了暂时停止二进制日志功能的语句。如果用户不希望自己执行的某些 SQL 语句记录在二进制日志中，可以在执行这些 SQL 语句之前暂停二进制日志功能。</p><p>使用 SET 语句来暂停/开启二进制日志功能，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET SQL_LOG_BIN&#x3D;0&#x2F;1;</span><br></pre></td></tr></table></figure><p>以上命令中，0 表示暂停二进制日志功能，1 表示开启二进制功能。</p><p>my.cnf 中的 [mysqld] 组下面有几个设置参数是关于二进制日志的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expire_logs_days &#x3D; 10</span><br><span class="line">max_binlog_size &#x3D; 1​00M</span><br></pre></td></tr></table></figure><ul><li>expire_logs_day 定义了 MySQL 清除过期日志的时间、二进制日志自动删除的天数。默认值为 0，表示“没有自动删除”。当 MySQL 启动或刷新二进制日志时可能删除。</li><li>max_binlog_size 定义了单个文件的大小限制，如果二进制日志写入的内容大小超出给定值，日志就会发生滚动（关闭当前文件，重新打开一个新的日志文件）。不能将该变量设置为大于 1GB 或小于 4096B（字节），其默认值是 1GB。</li></ul><h4 id="5-中继日志-reley-log"><a href="#5-中继日志-reley-log" class="headerlink" title="5. 中继日志(reley log)"></a>5. 中继日志(reley log)</h4><p>从服务器I/O线程将主服务器的二进制日志读取过来记录到从服务器本地文件，然后从服务器SQL线程会读取relay-log日志的内容并应用到从服务器，从而使从服务器和主服务器的数据保持一致</p><p>查询中继日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;%relay%&#39;;</span><br></pre></td></tr></table></figure><ul><li>max_ relay_ log_ size：relay log 允许的最大值，如果该值为0，则默认值为 max_binlog_size (1G)；如果不为0，则 max_relay_log_size 则为最大的relay_log文件大小；</li><li>relay_log：定义 relay_log 的位置和名称，如果值为空，则默认位置在数据文件的目录；</li><li>relay_ log_ index：定义 relay_log 索引的位置和名称，记录有几个 relay_ log 文件，默认为2个</li><li>relay_ log_ info_file：定义 relay-log.info 的位置和名称，relay-log.info 记录 master 主库的 binary_log 的恢复位置和 从库 relay_log 的位置；</li><li>relay_ log_purge：是否自动清空中继日志，默认值为1(启用)；</li><li>relay_ log_ recovery：当slave从库宕机后，假如relay-log损坏了，导致一部分中继日志没有处理，则自动放弃所有未执行的relay-log，并且重新从master上获取日志，这样就保证了relay-log的完整性。默认情况下该功能是关闭的，将relay_ log_recovery的值设置为 1时，可在slave从库上开启该功能，建议开启；</li><li>sync_relay_log：当设置为1时，slave的I/O线程每次接收到master发送过来的binlog日志都要写入系统缓冲区，然后刷入relay log中继日志里，这样是最安全的，因为在崩溃的时候，你最多会丢失一个事务，但会造成磁盘的大量I/O；当设置为0时，并不是马上就刷入中继日志里，而是由操作系统决定何时来写入，虽然安全性降低了，但减少了大量的磁盘I/O操作。这个值默认是0，可动态修改；</li><li>sync_ relay_ log_info：这个参数和 sync_relay_log 参数一样。</li></ul><h4 id="6-事务日志-transaction-log"><a href="#6-事务日志-transaction-log" class="headerlink" title="6. 事务日志(transaction  log)"></a>6. 事务日志(transaction  log)</h4><p>事务型存储引擎自行管理和使用</p><ul><li>redo  log    重做日志</li><li>undo  log   撤销日志</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql InnoDB事务</title>
      <link href="2022/03/08/mysql/InnoDB%E4%BA%8B%E5%8A%A1/"/>
      <url>2022/03/08/mysql/InnoDB%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="InnoDB事务"><a href="#InnoDB事务" class="headerlink" title="InnoDB事务"></a>InnoDB事务</h3><h4 id="支持事务安装"><a href="#支持事务安装" class="headerlink" title="支持事务安装"></a>支持事务安装</h4><p>InnoDB 最重要的一点就是支持事务，可以说这是 InnoDB 成为 MySQL 中最流行的存储引擎的一个非常重要的原因。</p><h5 id="ACID-—-事务基本要素"><a href="#ACID-—-事务基本要素" class="headerlink" title="ACID — 事务基本要素"></a>ACID — 事务基本要素</h5><p>事务是由一组SQL语句组成的逻辑处理单元，具有4个属性，通常简称为事务的ACID属性。</p><ul><li>A (Atomicity) 原子性：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样</li><li>C (Consistency) 一致性：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏</li><li>I(Isolation)隔离性：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰</li><li>D (Durability) 持久性：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚</li></ul><h5 id="并发事务处理带来的问题"><a href="#并发事务处理带来的问题" class="headerlink" title="并发事务处理带来的问题"></a>并发事务处理带来的问题</h5><ul><li>更新丢失（Lost Update)：事务A和事务B选择同一行，然后基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，就会发生丢失更新问题</li><li>脏读(Dirty Reads)：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li><li>不可重复读（Non-Repeatable Reads)：事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li><li>幻读（Phantom Reads)：幻读与不可重复读类似。它发生在一个事务A读取了几行数据，接着另一个并发事务B插入了一些数据时。在随后的查询中，事务A就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li></ul><h5 id="幻读和不可重复读的区别："><a href="#幻读和不可重复读的区别：" class="headerlink" title="幻读和不可重复读的区别："></a>幻读和不可重复读的区别：</h5><ul><li>不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）</li><li>幻读的重点在于新增或者删除：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）</li></ul><h5 id="并发事务处理带来的问题的解决办法："><a href="#并发事务处理带来的问题的解决办法：" class="headerlink" title="并发事务处理带来的问题的解决办法："></a>并发事务处理带来的问题的解决办法：</h5><ul><li>“更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。</li><li>“脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决：<ul><li>一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。</li><li>另一种是数据多版本并发控制（MultiVersion Concurrency Control，简称 MVCC 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)，并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本。 </li></ul></li></ul><h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><p>数据库事务的隔离级别有4种，由低到高分别为</p><table><thead><tr><th>隔离级别</th><th>脏读（Dirty Read）</th><th>不可重复读（NonRepeatable Read）</th><th>幻读（Phantom Read）</th></tr></thead><tbody><tr><td>未提交读（Read uncommitted）</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>已提交读（Read committed）</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>可重复读（Repeatable read）</td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td>可串行化（Serializable ）</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><ul><li>未提交读(Read Uncommitted)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。<span style="color:red">读未提交，就是一个事务可以读取另一个未提交事务的数据。</span></li></ul><blockquote><p>事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。</p><p>分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。</p></blockquote><ul><li>提交读(Read Committed)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。Oracle等多数数据库默认都是该级别 (不重复读)。<span style="color:red">一个事务要等另一个事务提交后才能读取数据。</span></li></ul><blockquote><p>事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…</p><p>分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。</p></blockquote><ul><li>可重复读(Repeated Read)：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。InnoDB默认级别。<span style="color:red">重复读，就是在开始读取数据（事务开启）时，不再允许修改操作</span></li></ul><blockquote><p>事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。</p><p>分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，<b>不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。</b></p><p><b>什么时候会出现幻读？</b></p><p>事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。</p></blockquote><ul><li>串行读(Serializable)：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><p>查看当前数据库的事务隔离级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;tx_isolation&#39;</span><br></pre></td></tr></table></figure><h5 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a>MVCC 多版本并发控制</h5><p>可以认为 MVCC 是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只是锁定必要的行。</p><p>MVCC 的实现是通过保存数据在某个时间点的快照来实现的。也就是说不管需要执行多长时间，每个事物看到的数据都是一致的。</p><p>典型的MVCC实现方式，分为乐观（optimistic）并发控制和悲观（pressimistic）并发控制。InnoDB 的 MVCC，它存储了每一行的三个额外的隐藏字段。</p><ul><li>DB_TRX_ID：一个6byte的标识，每处理一个事务，其值自动+1</li></ul><blockquote><p> “创建时间”和“删除时间”记录的就是这个DB_TRX_ID的值</p></blockquote><blockquote><p>DB_TRX _ID是最重要的一个，可以通过语句“show engine innodb status”来查找 </p></blockquote><ul><li><p>DB_ROLL_PTR: 大小是7byte,指向写到rollback segment（回滚段）的一条undo log记录</p><blockquote><p>（update操作的话，记录update前的ROW值）</p></blockquote></li><li><p>DB_ROW_ID: 大小是6byte,该值随新行插入单调增加。</p></li></ul><blockquote><p>当由innodb自动产生聚集索引时聚集索引(即没有主键时,因为MYSQL默认聚簇表,会自动生成一个ROWID)，包括这个DB_ROW_ID的值，不然的话聚集索引中不包括这个值,这个用于索引当中。</p></blockquote><p>DB_ TRX_ ID记录了行的创建的时间删除的时间在每个事件发生的时候，每行存储版本号，而不是存储事件实际发生的时间。每次事物的开始这个版本号都会增加。自记录时间开始，每个事物都会保存记录的系统版本号。依照事物的版本来检查每行的版本号。在insert操作时 “创建时间”=DB_ TRX_ ID，这时，“删除时间”是未定义的；在update时，复制新增行的“创建时间”=DB_ TRX_ ID，删除时间未定义，旧数据行“创建时间”不变，删除时间=该事务DB_ TRX_ ID；delete操作，相应数据行的“创建时间”不变，删除时间=该事务的DB_ ROW_ID；select操作对两者都不修改，只读相应的数据。</p><p><b>MVCC 只在 COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作。</b></p><h5 id="REPEATABLE-READ（可重读）隔离级别下MVCC如何工作："><a href="#REPEATABLE-READ（可重读）隔离级别下MVCC如何工作：" class="headerlink" title="REPEATABLE READ（可重读）隔离级别下MVCC如何工作："></a>REPEATABLE READ（可重读）隔离级别下MVCC如何工作：</h5><ul><li>SELECT：InnoDB会根据以下两个条件检查每行记录：<ul><li>InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在开始事务之前已经存在要么是事务自身插入或者修改过的</li><li>行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除</li><li>只有符合上述两个条件的才会被查询出来</li></ul></li><li>INSERT：InnoDB为新插入的每一行保存当前系统版本号作为行版本号</li><li>DELETE：InnoDB为删除的每一行保存当前系统版本号作为行删除标识</li><li>UPDATE：InnoDB为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识</li></ul><h5 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h5><p>事务的实现是基于数据库的存储引擎。不同的存储引擎对事务的支持程度不一样。MySQL 中支持事务的存储引擎有 InnoDB 和 NDB。</p><b>事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过 事务日志实现 。</b><p>事务日志包括：<br><br><b>重做日志redo和回滚日志undo</b><br></p><ul><li><b>redo log（重做日志）:</b>实现持久化和原子性 在innoDB的存储引擎中，事务日志通过重做(redo)日志和innoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化，这就是DBA们口中常说的“日志先行”(Write-Ahead Logging)。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。在系统启动的时候，就已经为redo log分配了一块连续的存储空间，以顺序追加的方式记录Redo Log，通过顺序IO来改善性能。所有的事务共享redo log的存储空间，它们的Redo Log按语句的执行顺序，依次交替的记录在一起。</li></ul><blockquote><p><b>redo log 刷盘时机</b><br><br>1.log buffer空间不足时<br><br>2.事务提交时<br><br>3.后台线程大约每秒刷新redo log到磁盘<br><br>4.正常关闭服务器时<br><br>5.checkpoint时</p></blockquote><ul><li><b>undo log（回滚日志）:</b>实现一致性；undo log 主要为事务的回滚服务。在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。<br>Undo记录的是已部分完成并且写入硬盘的未完成的事务，默认情况下回滚日志是记录下表空间中的（共享表空间或者独享表空间）</li></ul><p>二种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。二者记录的内容也不同，redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql存储引擎</title>
      <link href="2022/03/06/mysql/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>2022/03/06/mysql/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;数据库存储引擎是数据库底层软件组件，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据操作。简而言之，存储引擎就是指表的类型。数据库的存储引擎决定了表在计算机中的存储方式。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎还可以获得特定的功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;MySQL 5.7 支持的存储引擎有 InnoDB、MyISAM、Memory、Merge、Archive、CSV、BLACKHOLE 等。</p><p>查看系统支持的引擎</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW ENGINES;</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>Engine：引擎名称</p></li><li><p>Support：表示某种引擎是否能使用 YES表示可以使用，NO表示不能使用，DEFAULT表示该引擎为当前默认的存储引擎。</p></li><li><p>Comment：描述</p></li><li><p>Transations: 是否支持事务</p></li><li><p>XA：是否支持XA事务。</p></li><li><p>Savepoints：是否支持保存点。</p></li></ol></blockquote><table><thead><tr><th>存储殷勤</th><th>描述</th></tr></thead><tbody><tr><td>ARCHIVE</td><td>用于数据存档的引擎，数据被插入后就不能在修改了，且不支持索引。</td></tr><tr><td>CSV</td><td>在存储数据时，会以逗号作为数据项之间的分隔符。</td></tr><tr><td>BLACKHOLE</td><td>会丢弃写操作，该操作会返回空内容。</td></tr><tr><td>FEDERATED</td><td>将数据存储在远程数据库中，用来访问远程表的存储引擎。</td></tr><tr><td>InnoDB</td><td>具备外键支持功能的事务处理引擎</td></tr><tr><td>MEMORY</td><td>置于内存的表</td></tr><tr><td>MERGE</td><td>用来管理由多个 MyISAM 表构成的表集合</td></tr><tr><td>MyISAM</td><td>主要的非事务处理存储引擎</td></tr><tr><td>NDB</td><td>MySQL 集群专用存储引擎</td></tr></tbody></table><blockquote><p>有几种存储引擎的名字还有同义词，例如，MRG_MyISAM 和 NDBCLUSTER 分别是 MERGE 和 NDB 的同义词。存储引擎 MEMORY 和 InnoDB 在早期分别称为 HEAP 和 Innobase。虽然后面两个名字仍能被识别，但是已经被废弃了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql系统变量</title>
      <link href="2022/03/06/mysql/%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F/"/>
      <url>2022/03/06/mysql/%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><h5 id="查看系统变量"><a href="#查看系统变量" class="headerlink" title="查看系统变量"></a>查看系统变量</h5><p>查看所有全局变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL VARIABLES; </span><br></pre></td></tr></table></figure><p>查看与当前会话相关的所有会话变量以及全局变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW SESSION VARIABLES;</span><br></pre></td></tr></table></figure><p>MySQL 中的系统变量以两个“@”开头。</p><ul><li>@@global 仅仅用于标记全局变量；</li><li>@@session 仅仅用于标记会话变量；</li><li>@@ 首先标记会话变量，如果会话变量不存在，则标记全局变量。</li></ul><p>#####设置系统变量</p><p>可以通过以下方法设置系统变量：</p><blockquote><ol><li><p>修改 MySQL 源代码，然后对 MySQL 源代码重新编译（该方法适用于 MySQL 高级用户，这里不做阐述）。</p></li><li><p>在 MySQL 配置文件（mysql.ini 或 mysql.cnf）中修改 MySQL 系统变量的值（需要重启 MySQL 服务才会生效）。</p></li><li><p>在 MySQL 服务运行期间，使用 SET 命令重新设置系统变量的值。</p></li></ol></blockquote><p>设置全局变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET @@global.innodb_file_per_table&#x3D;default;</span><br><span class="line">SET @@global.innodb_file_per_table&#x3D;ON;</span><br><span class="line">SET global innodb_file_per_table&#x3D;ON;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，更改全局变量只影响更改后连接客户端的相应会话变量，而不会影响目前已经连接的客户端的会话变量（即使客户端执行 SET GLOBAL 语句也不影响）。也就是说，对于修改全局变量之前连接的客户端只有在客户端重新连接后，才会影响到客户端。</p></blockquote><p>设置会话变量的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET @@session.pseudo_thread_id&#x3D;5;</span><br><span class="line">SET session pseudo_thread_id&#x3D;5;</span><br><span class="line">SET @@pseudo_thread_id&#x3D;5;</span><br><span class="line">SET pseudo_thread_id &#x3D; 5;</span><br></pre></td></tr></table></figure><p>如果没有指定修改全局变量还是会话变量，服务器会当作会话变量来处理。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET @@sort_buffer_size &#x3D; 50000;</span><br></pre></td></tr></table></figure><p>上面语句没有指定是 GLOBAL 还是 SESSION，服务器会当做 SESSION 处理。</p><blockquote><p>MySQL 中还有一些特殊的全局变量，如 log_bin、tmpdir、version、datadir，在 MySQL 服务实例运行期间它们的值不能动态修改，也就是不能使用 SET 命令进行重新设置，这种变量称为静态变量。数据库管理员可以使用前面提到的修改源代码或更改配置文件来重新设置静态变量的值。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql数据类型</title>
      <link href="2022/03/06/mysql/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
      <url>2022/03/06/mysql/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>###数据类型</p><h5 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;整数类型包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，浮点数类型包括 FLOAT 和 DOUBLE，定点数类型为 DECIMAL。 </p><table><thead><tr><th>类型</th><th>大小</th><th>范围（有符号）</th><th>范围（无符号）</th><th>用途</th></tr></thead><tbody><tr><td>TINYINT</td><td>1 Bytes</td><td>(-128，127)</td><td>(0，255)</td><td>小整数值</td></tr><tr><td>SMALLINT</td><td>2 Bytes</td><td>(-32 768，32 767)</td><td>(0，65 535)</td><td>大整数值</td></tr><tr><td>MEDIUMINT</td><td>3 Bytes</td><td>(-8 388 608，8 388 607)</td><td>(0，16 777 215)</td><td>大整数值</td></tr><tr><td>INT或INTEGER</td><td>4 Bytes</td><td>(-2 147 483 648，2 147 483 647)</td><td>(0，4 294 967 295)</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8 Bytes</td><td>(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td>(0，18 446 744 073 709 551 615)</td><td>极大整数值</td></tr><tr><td>FLOAT</td><td>4 Bytes</td><td>(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td>0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td>单精度浮点数值</td></tr><tr><td>DOUBLE</td><td>8 Bytes</td><td>(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td>0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td>双精度浮点数值</td></tr><tr><td>DECIMAL</td><td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td>依赖于M和D的值</td><td>依赖于M和D的值</td><td>小数值</td></tr></tbody></table><blockquote><p><span style="color:red;">整数：不同的整数类型有不同的取值范围，并且需要不同的存储空间，因此应根据实际需要选择最合适的类型，这样有利于提高查询的效率和节省存储空间。</span></p></blockquote><blockquote><p><span style="color:red;">浮点数：不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好，另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。</span></p></blockquote><h5 id="日期-时间类型"><a href="#日期-时间类型" class="headerlink" title="日期/时间类型"></a>日期/时间类型</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;包括 YEAR、TIME、DATE、DATETIME 和 TIMESTAMP。</p><table><thead><tr><th>类型</th><th>大小( bytes)</th><th>范围（有符号）</th><th>格式</th><th>用途</th></tr></thead><tbody><tr><td>DATE</td><td>3</td><td>1000-01-01/9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td>‘-838:59:59’/‘838:59:59’</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1</td><td>1901/2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8</td><td>1000-01-01 00:00:00/9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01 00:00:00/2038 结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td>YYYYMMDD HHMMSS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table><h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;包括 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。</p><table><thead><tr><th>类型</th><th>大小</th><th>说明</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255 bytes</td><td>固定长度非二进制字符串</td></tr><tr><td>VARCHAR</td><td>0-65535 bytes</td><td>变长非二进制字符串</td></tr><tr><td>TINYTEXT</td><td>0-255 bytes</td><td>短文本字符串（非二进制）</td></tr><tr><td>TEXT</td><td>0-65 535 bytes</td><td>长文本数据（非二进制）</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215 bytes</td><td>中等长度文本数据（非二进制）</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295 bytes</td><td>极大文本数据（非二进制）</td></tr><tr><td>BLOB</td><td>0-65 535 bytes</td><td>二进制形式的长文本数据</td></tr><tr><td>TINYBLOB</td><td>0-255 bytes</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215 bytes</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295 bytes</td><td>二进制形式的极大文本数据</td></tr><tr><td>ENUM</td><td>1或2个字节，取决于枚举值的数目 (最大值为65535)</td><td>枚举类型，只能有一个枚举字符串值</td></tr><tr><td>SET</td><td>1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</td><td>一个设置，字符串对象可以有零个或 多个SET成员</td></tr></tbody></table><blockquote><p>注意：char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。</p></blockquote><blockquote><p>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p><p>提示：ENUM 列总有一个默认值。如果将 ENUM 列声明为 NULL，NULL 值则为该列的一个有效值，并且默认值为 NULL。如果 ENUM 列被声明为 NOT NULL，其默认值为允许的值列表的第 1 个元素。</p><p>提示：如果插入 SET 字段中的列值有重复，则 MySQL 自动删除重复的值；插入 SET 字段的值的顺序并不重要，MySQL 会在存入数据库时，按照定义的顺序显示；如果插入了不正确的值，默认情况下，MySQL 将忽视这些值，给出警告。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基本操作</title>
      <link href="2022/03/06/mysql/%E5%9F%BA%E7%A1%80/"/>
      <url>2022/03/06/mysql/%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><h4 id="1-进入mysql"><a href="#1-进入mysql" class="headerlink" title="1. 进入mysql"></a>1. 进入mysql</h4><p><code>mysql -u root -p</code></p><h4 id="2-查看有哪些数据库"><a href="#2-查看有哪些数据库" class="headerlink" title="2. 查看有哪些数据库"></a>2. 查看有哪些数据库</h4><p><code>SHOW DATABASES [LIKE &#39;数据库名&#39;];</code></p><ul><li>LIKE 从句是可选项，用于匹配指定的数据库名称。LIKE 从句可以部分匹配，也可以完全匹配。</li><li>数据库名由单引号’ ‘包围。</li></ul><h4 id="3-创建数据库"><a href="#3-创建数据库" class="headerlink" title="3. 创建数据库"></a>3. 创建数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE [IF NOT EXISTS] &lt;数据库名&gt;</span><br><span class="line">[[DEFAULT] CHARACTER SET &lt;字符集名&gt;] </span><br><span class="line">[[DEFAULT] COLLATE &lt;校对规则名&gt;];</span><br></pre></td></tr></table></figure><ul><li>&lt;数据库名&gt;：创建数据库的名称。MySQL 的数据存储区将以目录方式表示 MySQL 数据库，因此数据库名称必须符合操作系统的文件夹命名规则，不能以数字开头，尽量要有实际意义。注意在 MySQL 中不区分大小写。</li><li>IF NOT EXISTS：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。此选项可以用来避免数据库已经存在而重复创建的错误。</li><li>[DEFAULT] CHARACTER SET：指定数据库的字符集。指定字符集的目的是为了避免在数据库中存储的数据出现乱码的情况。如果在创建数据库时不指定字符集，那么就使用系统的默认字符集。</li><li>[DEFAULT] COLLATE：指定字符集的默认校对规则。</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE &#96;test_local2&#96; DEFAULT CHARACTER SET &#x3D; &#96;utf8&#96; DEFAULT COLLATE &#x3D; &#96;utf8_general_ci&#96;;</span><br></pre></td></tr></table></figure><h4 id="4-修改数据库"><a href="#4-修改数据库" class="headerlink" title="4. 修改数据库"></a>4. 修改数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE [数据库名] &#123; </span><br><span class="line">[ DEFAULT ] CHARACTER SET &lt;字符集名&gt; |</span><br><span class="line">[ DEFAULT ] COLLATE &lt;校对规则名&gt;&#125;</span><br></pre></td></tr></table></figure><ul><li>ALTER DATABASE 用于更改数据库的全局特性。</li><li>使用 ALTER DATABASE 需要获得数据库 ALTER 权限。</li><li>数据库名称可以忽略，此时语句对应于默认数据库。</li><li>CHARACTER SET 子句用于更改默认的数据库字符集。</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE test_db</span><br><span class="line"> DEFAULT CHARACTER SET gb2312</span><br><span class="line"> DEFAULT COLLATE gb2312_chinese_ci;</span><br></pre></td></tr></table></figure><h4 id="5-删除数据库"><a href="#5-删除数据库" class="headerlink" title="5.删除数据库"></a>5.删除数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE [ IF EXISTS ] &lt;数据库名&gt;</span><br></pre></td></tr></table></figure><ul><li>&lt;数据库名&gt;：指定要删除的数据库名。</li><li>IF EXISTS：用于防止当数据库不存在时发生错误。</li><li>DROP DATABASE：删除数据库中的所有表格并同时删除数据库。使用此语句时要非常小心，以免错误删除。如果要使用 DROP DATABASE，需要获得数据库 DROP 权限。</li></ul><h4 id="6-选择数据库"><a href="#6-选择数据库" class="headerlink" title="6. 选择数据库"></a>6. 选择数据库</h4><p><code>use &lt;数据库名&gt;</code></p><h4 id="7-查看有哪些表"><a href="#7-查看有哪些表" class="headerlink" title="7. 查看有哪些表"></a>7. 查看有哪些表</h4><p><code>show tables</code></p><h4 id="8-创建表"><a href="#8-创建表" class="headerlink" title="8. 创建表"></a>8. 创建表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &lt;表名&gt; ([表定义选项])[表选项][分区选项];</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;yii2_ad&#96; (</span><br><span class="line">  &#96;id&#96; int(8) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;type&#96; tinyint(3) NOT NULL COMMENT &#39;类型&#39;,</span><br><span class="line">  &#96;title&#96; varchar(50) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;标题&#39;,</span><br><span class="line">  &#96;image&#96; varchar(255) NOT NULL COMMENT &#39;图片路径&#39;,</span><br><span class="line">  &#96;url&#96; varchar(255) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;跳转地址&#39;,</span><br><span class="line">  &#96;sort&#96; int(5) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;排序&#39;,</span><br><span class="line">  &#96;create_time&#96; int(10) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;创建时间&#39;,</span><br><span class="line">  &#96;update_time&#96; int(10) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;更新时间&#39;,</span><br><span class="line">  &#96;status&#96; tinyint(1) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;状态&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;2 DEFAULT CHARSET&#x3D;utf8 ROW_FORMAT&#x3D;DYNAMIC COMMENT&#x3D;&#39;图片广告&#39;;</span><br></pre></td></tr></table></figure><h4 id="9-查看表结构"><a href="#9-查看表结构" class="headerlink" title="9. 查看表结构"></a>9. 查看表结构</h4><h5 id="1-表格形式展现表结构"><a href="#1-表格形式展现表结构" class="headerlink" title="1) 表格形式展现表结构"></a><em>1) 表格形式展现表结构</em></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESCRIBE &lt;表名&gt;;</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC &lt;表名&gt;;</span><br></pre></td></tr></table></figure><p>字段的含义如下：</p><ul><li>Field：表字段</li><li>Type：各字段数据类型</li><li>Null：表示该列是否可以存储 NULL 值。</li><li>Key：表示该列是否已编制索引。PRI 表示该列是表主键的一部分，UNI 表示该列是 UNIQUE 索引的一部分，MUL 表示在列中某个给定值允许出现多次。</li><li>Default：表示该列是否有默认值，如果有，值是多少。</li><li>Extra：表示可以获取的与给定列有关的附加信息，如 AUTO_INCREMENT 等。</li></ul><h5 id="1-以SQL语句的形式展示表结构"><a href="#1-以SQL语句的形式展示表结构" class="headerlink" title="1) 以SQL语句的形式展示表结构"></a><em>1) 以SQL语句的形式展示表结构</em></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE &lt;表名&gt;;</span><br></pre></td></tr></table></figure><ul><li>在 SHOW CREATE TABLE 语句的结尾处（分号前面）添加\g或者\G参数可以改变展示形式。</li></ul><h4 id="10-修改表"><a href="#10-修改表" class="headerlink" title="10. 修改表"></a>10. 修改表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; [修改选项]</span><br></pre></td></tr></table></figure><p>修改项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; ADD COLUMN &lt;列名&gt; &lt;类型&gt;</span><br><span class="line">| CHANGE COLUMN &lt;旧列名&gt; &lt;新列名&gt; &lt;新列类型&gt;</span><br><span class="line">| ALTER COLUMN &lt;列名&gt; &#123; SET DEFAULT &lt;默认值&gt; | DROP DEFAULT &#125;</span><br><span class="line">| MODIFY COLUMN &lt;列名&gt; &lt;类型&gt;</span><br><span class="line">| DROP COLUMN &lt;列名&gt;</span><br><span class="line">| RENAME TO &lt;新表名&gt;</span><br><span class="line">| CHARACTER SET &lt;字符集名&gt;</span><br><span class="line">| COLLATE &lt;校对规则名&gt; &#125;</span><br></pre></td></tr></table></figure><h5 id="1-修改表名"><a href="#1-修改表名" class="headerlink" title="1) 修改表名"></a><em>1) 修改表名</em></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;旧表名&gt; RENAME [TO] &lt;新表名&gt;；</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student RENAME TO tb_students_info;</span><br></pre></td></tr></table></figure><h5 id="2-修改表字符集"><a href="#2-修改表字符集" class="headerlink" title="2) 修改表字符集"></a><em>2) 修改表字符集</em></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 [DEFAULT] CHARACTER SET &lt;字符集名&gt; [DEFAULT] COLLATE &lt;校对规则名&gt;;</span><br></pre></td></tr></table></figure><ul><li>DEFAULT 为可选参数，使用与否均不影响结果。</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tb_students_info CHARACTER SET gb2312  DEFAULT COLLATE gb2312_chinese_ci;</span><br></pre></td></tr></table></figure><h5 id="3-添加字段"><a href="#3-添加字段" class="headerlink" title="3) 添加字段"></a><em>3) 添加字段</em></h5><h6 id="末尾添加字段"><a href="#末尾添加字段" class="headerlink" title="末尾添加字段"></a>末尾添加字段</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; ADD &lt;新字段名&gt;&lt;数据类型&gt;[约束条件];</span><br></pre></td></tr></table></figure><p>语法格式:</p><ul><li>&lt;表名&gt; 为数据表的名字；</li><li>&lt;新字段名&gt; 为所要添加的字段的名字；</li><li>&lt;数据类型&gt; 为所要添加的字段能存储数据的数据类型</li><li>[约束条件] 是可选的，用来对添加的字段进行约束。</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student ADD age INT(4);</span><br></pre></td></tr></table></figure><h6 id="头部加字段"><a href="#头部加字段" class="headerlink" title="头部加字段"></a>头部加字段</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; ADD &lt;新字段名&gt; &lt;数据类型&gt; [约束条件] FIRST;</span><br></pre></td></tr></table></figure><ul><li>FIRST 关键字一般放在语句的末尾。</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student ADD stuId INT(4) FIRST;</span><br></pre></td></tr></table></figure><h5 id="4-修改字段名称"><a href="#4-修改字段名称" class="headerlink" title="4) 修改字段名称"></a><em>4) 修改字段名称</em></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; CHANGE &lt;旧字段名&gt; &lt;新字段名&gt; &lt;新数据类型&gt;；</span><br></pre></td></tr></table></figure><ul><li>旧字段名：指修改前的字段名；</li><li>新字段名：指修改后的字段名；</li><li>新数据类型：指修改后的数据类型，如果不需要修改字段的数据类型，可以将新数据类型设置成与原来一样，但数据类型不能为空。</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tb_emp1 CHANGE col1 col3 CHAR(30);</span><br></pre></td></tr></table></figure><h5 id="5-修改字段数据类型"><a href="#5-修改字段数据类型" class="headerlink" title="5) 修改字段数据类型"></a><em>5) 修改字段数据类型</em></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名&gt; &lt;数据类型&gt;</span><br></pre></td></tr></table></figure><ul><li>表名：指要修改数据类型的字段所在表的名称；</li><li>字段名：指需要修改的字段；</li><li>数据类型：指修改后字段的新数据类型。</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tb_emp1 MODIFY name VARCHAR(30);</span><br></pre></td></tr></table></figure><h5 id="6-删除字段"><a href="#6-删除字段" class="headerlink" title="6) 删除字段"></a><em>6) 删除字段</em></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; DROP &lt;字段名&gt;；</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tb_emp1 DROP col2;</span><br></pre></td></tr></table></figure><h4 id="11-删除表"><a href="#11-删除表" class="headerlink" title="11. 删除表"></a>11. 删除表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] 表名1 [ ,表名2, 表名3 ...]</span><br></pre></td></tr></table></figure><ul><li>表名1, 表名2, 表名3 …表示要被删除的数据表的名称。DROP TABLE 可以同时删除多个表，只要将表名依次写在后面，相互之间用逗号隔开即可。</li><li>IF EXISTS 用于在删除数据表之前判断该表是否存在。如果不加 IF EXISTS，当数据表不存在时 MySQL 将提示错误，中断 SQL 语句的执行；加上 IF EXISTS 后，当数据表不存在时 SQL 语句可以顺利执行，但是会发出警告（warning）。</li><li>用户必须拥有执行 DROP TABLE 命令的权限，否则数据表不会被删除。</li><li>表被删除时，用户在该表上的权限不会自动删除。</li></ul><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE tb_emp3;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>elasticsearch(二)</title>
      <link href="2021/05/26/elasticsearch-2/"/>
      <url>2021/05/26/elasticsearch-2/</url>
      
        <content type="html"><![CDATA[<h3 id="cat用法"><a href="#cat用法" class="headerlink" title="cat用法"></a>cat用法</h3><ul><li>format：（字符串）表明请求返回的参数结构可配置：<ul><li>JSON：返回JSON格式的参数</li><li>YAML：返回YAML格式的参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;请求</span><br><span class="line">GET &#x2F;_cat&#x2F;master?format&#x3D;JSON</span><br><span class="line">&#x2F;&#x2F;返回</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;id&quot; : &quot;-HeJQJGQSBeZRQhtomWKrg&quot;,</span><br><span class="line">        &quot;host&quot; : &quot;127.0.0.1&quot;,</span><br><span class="line">        &quot;ip&quot; : &quot;127.0.0.1&quot;,</span><br><span class="line">        &quot;node&quot; : &quot;bogon&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul></li><li>h：（字符串）返回指定的列，指定列时用逗号分割  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;请求</span><br><span class="line">GET &#x2F;_cat&#x2F;master?h&#x3D;id,host&amp;format&#x3D;JSON</span><br><span class="line">&#x2F;&#x2F;返回</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;id&quot; : &quot;-HeJQJGQSBeZRQhtomWKrg&quot;,</span><br><span class="line">        &quot;host&quot; : &quot;127.0.0.1&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li>help：（布尔）为true时返回帮助信息，默认为false  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;请求</span><br><span class="line">GET &#x2F;_cat&#x2F;master?help&#x3D;true</span><br><span class="line">&#x2F;&#x2F;返回</span><br><span class="line">id   |   | node id    </span><br><span class="line">host | h | host name  </span><br><span class="line">ip   |   | ip address</span><br><span class="line">node | n | node name</span><br></pre></td></tr></table></figure></li><li>local：(布尔)如果为true，则请求仅从本地节点检索信息。默认为false，表示从主节点检索信息。</li><li>s：（字符串）按指定的列进行排序，用逗号分割指定多个列  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;请求</span><br><span class="line">GET &#x2F;_cat&#x2F;aliases?s&#x3D;alias&amp;format&#x3D;JSON</span><br><span class="line">&#x2F;&#x2F;返回太多自己执行看</span><br></pre></td></tr></table></figure></li><li>v：（布尔）如果为true，则响应包括列标题。默认为false。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;请求</span><br><span class="line">GET &#x2F;_cat&#x2F;master?v&#x3D;true</span><br><span class="line">&#x2F;&#x2F;返回</span><br><span class="line">id                     host      ip        node</span><br><span class="line">-HeJQJGQSBeZRQhtomWKrg 127.0.0.1 127.0.0.1 bogon</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>elasticsearch安装(一)</title>
      <link href="2021/05/26/elasticsearch-1/"/>
      <url>2021/05/26/elasticsearch-1/</url>
      
        <content type="html"><![CDATA[<h3 id="准备elasticsearch运行环境"><a href="#准备elasticsearch运行环境" class="headerlink" title="准备elasticsearch运行环境"></a>准备elasticsearch运行环境</h3><p>Elasticsearch至少需要Java8，在下载之前运行下面内容检查java版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$JAVA_HOME</span></span><br></pre></td></tr></table></figure><p>如果没有安装可以去<a href="https://www.java.com/zh-CN/">Oracle</a> 网站下载适合的版本。<br>安装完JAVA之后就可以下载Elasticsearch<br><br></p><h3 id="Homebrew安装elasticsearch"><a href="#Homebrew安装elasticsearch" class="headerlink" title="Homebrew安装elasticsearch"></a>Homebrew安装elasticsearch</h3><p>使用Homebrew进行安装，首先需要创建Elastic Homebrew存储库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew tap elastic&#x2F;tap</span><br></pre></td></tr></table></figure><p>创建Elastic Homebrew存储库后，可以使用brew install安装Elasticsearch：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install elastic&#x2F;tap&#x2F;elasticsearch-full</span><br></pre></td></tr></table></figure><p>其它安装方式参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/install-elasticsearch.html">官网</a></p>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>elasticsearch 7 添加用户名密码认证</title>
      <link href="2021/05/13/elasticsearch_password/"/>
      <url>2021/05/13/elasticsearch_password/</url>
      
        <content type="html"><![CDATA[<h3 id="修改ES配置"><a href="#修改ES配置" class="headerlink" title="修改ES配置"></a>修改ES配置</h3><p>在elasticsearch.yml配置文件中添加下面项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xpack.security.enabled: true </span><br></pre></td></tr></table></figure><p>保存配置文件信息之后重启elasticsearch<br><br></p><h3 id="配置密码"><a href="#配置密码" class="headerlink" title="配置密码"></a>配置密码</h3><p>运行elasticsearch-setup-passwords interactive 引导你设置各种组件的密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">elasticsearch-setup-passwords interactive</span><br><span class="line">Initiating the setup of passwords for reserved users elastic,apm_system,kibana,kibana_system,logstash_system,beats_system,remote_monitoring_user.</span><br><span class="line">You will be prompted to enter passwords as the process progresses.</span><br><span class="line">Please confirm that you would like to continue [y&#x2F;N]y</span><br><span class="line"></span><br><span class="line">Enter password for [elastic]:</span><br><span class="line">Reenter password for [elastic]:</span><br><span class="line">Enter password for [apm_system]:</span><br><span class="line">Reenter password for [apm_system]:</span><br><span class="line">Enter password for [kibana_system]:</span><br><span class="line">Reenter password for [kibana_system]:</span><br><span class="line">Enter password for [logstash_system]:</span><br><span class="line">Reenter password for [logstash_system]:</span><br><span class="line">Enter password for [beats_system]:</span><br><span class="line">Reenter password for [beats_system]:</span><br><span class="line">Enter password for [remote_monitoring_user]:</span><br><span class="line">Reenter password for [remote_monitoring_user]:</span><br><span class="line">Changed password for user [apm_system]</span><br><span class="line">Changed password for user [kibana_system]</span><br><span class="line">Changed password for user [kibana]</span><br><span class="line">Changed password for user [logstash_system]</span><br><span class="line">Changed password for user [beats_system]</span><br><span class="line">Changed password for user [remote_monitoring_user]</span><br><span class="line">Changed password for user [elastic]</span><br></pre></td></tr></table></figure><h3 id="配置-kibana-yml文件访问es账号密码"><a href="#配置-kibana-yml文件访问es账号密码" class="headerlink" title="配置 kibana.yml文件访问es账号密码"></a>配置 kibana.yml文件访问es账号密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elasticsearch.username: &quot;elastic&quot;</span><br><span class="line">elasticsearch.password: &quot;123456&quot;</span><br></pre></td></tr></table></figure><h3 id="配置logstash输出到es"><a href="#配置logstash输出到es" class="headerlink" title="配置logstash输出到es"></a>配置logstash输出到es</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">  elasticsearch&#123;</span><br><span class="line">    #es服务地址</span><br><span class="line">    hosts &#x3D;&gt;[&quot;localhost:9200&quot;]</span><br><span class="line">    user &#x3D;&gt; &quot;elastic&quot;</span><br><span class="line">    password &#x3D;&gt; &quot;123456&quot;</span><br><span class="line">    #索引名称</span><br><span class="line">    index &#x3D;&gt; &quot;test-log-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">   stdout &#123; codec &#x3D;&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yii2 composer install 出错的解决方法</title>
      <link href="2021/05/13/composer_yii2/"/>
      <url>2021/05/13/composer_yii2/</url>
      
        <content type="html"><![CDATA[<p>下载yii2报下面错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your requirements could not be resolved to an installable set of packages.</span><br></pre></td></tr></table></figure><p>经查找需要全局安装fxp/composer-asset-plugin。<br><br><br>使用下面命令下载包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer global require <span class="string">&quot;fxp/composer-asset-plugin:^1.4.1&quot;</span></span><br></pre></td></tr></table></figure><p>报下面错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Package fxp&#x2F;composer-asset-plugin has a PHP requirement incomp   atible with your PHP version, PHP extensions and Composer vers   ion</span><br></pre></td></tr></table></figure><p>解决方法：<br><br><br>将composer降级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer self-update --1</span><br></pre></td></tr></table></figure><p>再执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer global require <span class="string">&quot;fxp/composer-asset-plugin:^1.4.1&quot;</span></span><br></pre></td></tr></table></figure><p>再将composer的版本升回来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer self-update</span><br></pre></td></tr></table></figure><p>即可</p>]]></content>
      
      
      <categories>
          
          <category> yii2 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>filebeat+logstash收集json格式的日志</title>
      <link href="2021/05/12/elk_filebeat_logstash/"/>
      <url>2021/05/12/elk_filebeat_logstash/</url>
      
        <content type="html"><![CDATA[<h3 id="配置logstash"><a href="#配置logstash" class="headerlink" title="配置logstash"></a>配置logstash</h3><p>创建一个first-pipeline.conf文件，配置以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">     host &#x3D;&gt; &quot;127.0.0.1&quot;</span><br><span class="line">     port &#x3D;&gt; 5044</span><br><span class="line">     type &#x3D;&gt; &quot;log4j&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># The filter part of this file is commented out to indicate that it is</span><br><span class="line"># optional.</span><br><span class="line"> filter &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> #控制台打印，便于调试和观察</span><br><span class="line">output &#123;</span><br><span class="line">   stdout &#123; codec &#x3D;&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行下面命令查看配置是否有问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;logstash -f first-pipeline.conf --config.test_and_exit</span><br></pre></td></tr></table></figure><p>看到有显示Configuration OK，标识配置没有问题，一些WARN的错误可以直接无视<br><br><br>执行下面代码启动logstash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;logstash -f first-pipeline.conf --config.reload.automatic</span><br></pre></td></tr></table></figure><h3 id="配置filebeat"><a href="#配置filebeat" class="headerlink" title="配置filebeat"></a>配置filebeat</h3><p>filebeat.yml——修改两个地方：input和output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  enabled: true</span><br><span class="line">#日志存放的路径，从根目录开始</span><br><span class="line">  paths: </span><br><span class="line">    - &#x2F;var&#x2F;log&#x2F;*log</span><br><span class="line">  json.keys_under_root: true</span><br><span class="line">  json.overwrite_keys: true</span><br><span class="line">#这里ip地址和端口填安装logstash的主机ip和对应logstash开放端口</span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: [&quot;localhost:5044&quot;]</span><br></pre></td></tr></table></figure><p>直接修改filebeat.yml文件有可能不生效，可以把原文件修改文件名然后自己重新创建filebeat.yml文件<br><br><br>配置完成后运行下面代码启动filebeat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filebeat -e -c filebeat.yml -d &quot;Publish&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo在文章中添加图片</title>
      <link href="2021/05/07/hexo_quote_image/"/>
      <url>2021/05/07/hexo_quote_image/</url>
      
        <content type="html"><![CDATA[<h3 id="hexo-添加图片插件"><a href="#hexo-添加图片插件" class="headerlink" title="hexo 添加图片插件"></a>hexo 添加图片插件</h3><p>安装图片插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>在_config.yml配置文件中，修改为 post_asset_folder: true， 然后新建一篇文章</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post ceshi</span><br></pre></td></tr></table></figure><p>这个时候会出现一个ceshi.md 和 ceshi的文件夹<br><br>文件夹中放入要展示的图片文件,使用macdown语法就可以在文章中引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[test](1.jpg)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串的二进制安全</title>
      <link href="2021/05/07/php_string_safe/"/>
      <url>2021/05/07/php_string_safe/</url>
      
        <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>PHP在处理带二进制字符的字符串时，程序不会对其中的数据做任何限制、过滤或者假设，数据在写入时是什么样的，它被读取是就是什么样，这种能力称为字符串的二进制安全<br><br/></p><h4 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h4><ul><li><p>C代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    <span class="keyword">char</span> a[] = <span class="string">&quot;aaa\0b&quot;</span>; <span class="comment">/*带有二进制数据的字符串*/</span></span><br><span class="line">    <span class="keyword">char</span> b[] = <span class="string">&quot;aaa\0c&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strcmp</span>(a,b)); <span class="comment">/*输出0*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(b));<span class="comment">/*输出3*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C认为a和b这两个变量的值相等，b的长度为3；</p></li><li><p>PHP代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&quot;aaa\0b&quot;</span>;<span class="comment">/*带有二进制数据的字符串*/</span></span><br><span class="line"><span class="variable">$b</span> = <span class="string">&quot;bbb\0c&quot;</span>;</span><br><span class="line">var_dump(strcmp(<span class="variable">$b</span>,<span class="variable">$a</span>)); <span class="comment">/*输出1*/</span></span><br><span class="line">var_dump(strlen(<span class="variable">$b</span>));<span class="comment">/*输出5*/</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>PHP认为a和b这两个变量的值不相等，且b的长度是5</p><br>对于C语言来说，"\0"就是字符串的结束，当读取字符串"aaa\0b"时，读到"\0"就会默认字符串读取已经结束<br>对于PHP7来说，其通过zend_string结构体对字符串重新封装，读取的数据长度以自身结构体len值为准，保证了字符串读写的二进制安全</li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP7学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mac下修改docker国内镜像</title>
      <link href="2021/04/27/registry_mirrors/"/>
      <url>2021/04/27/registry_mirrors/</url>
      
        <content type="html"><![CDATA[<h3 id="修改国内镜像"><a href="#修改国内镜像" class="headerlink" title="修改国内镜像"></a>修改国内镜像</h3><p>docker =&gt; Preferences<br><img src="/2021/04/27/registry_mirrors/preferences.png"><br>docker Engine 编辑配置文件<br><img src="/2021/04/27/registry_mirrors/dockerEngine.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;registry-mirrors&quot;: [</span><br><span class="line">   &quot;https:&#x2F;&#x2F;md4nbj2f.mirror.aliyuncs.com&quot;,</span><br><span class="line">   &quot;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&quot;,</span><br><span class="line">   &quot;https:&#x2F;&#x2F;hub-mirror.c.163.com&quot;</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure><p>点击Apply &amp; Restart按钮</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JS清空input[type=file]的值</title>
      <link href="2021/04/26/web/clear_input_file/"/>
      <url>2021/04/26/web/clear_input_file/</url>
      
        <content type="html"><![CDATA[<p>js 不能操作 input[type=file]，但可以将这个 input 的 dom 元素删除掉,再新增一个，或者替换掉</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#UploadFile&quot;</span>).replaceWith(<span class="string">&#x27;&lt;input id=&quot;UploadFile&quot; type=&quot;file&quot;/&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure><p>替换input框之后 input[type=file] 如果不是使用delegate绑定的事件，那么原本绑定的事件就会失效。<br>delegate() 方法为指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数。<br>使用 delegate() 方法的事件处理程序适用于当前或未来的元素（比如由脚本创建的新元素）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).delegate(<span class="string">&quot;#UploadFile&quot;</span>,<span class="string">&quot;change&quot;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js读取或修改url中的参数</title>
      <link href="2021/04/26/web/js_url_read_update/"/>
      <url>2021/04/26/web/js_url_read_update/</url>
      
        <content type="html"><![CDATA[<h3 id="读取url的某个参数"><a href="#读取url的某个参数" class="headerlink" title="读取url的某个参数"></a>读取url的某个参数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取URL参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetQueryString</span>(<span class="params">name</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;(^|&amp;)&quot;</span> + name + <span class="string">&quot;=([^&amp;]*)(&amp;|$)&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> r = <span class="built_in">window</span>.location.search.substr(<span class="number">1</span>).match(reg);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">unescape</span>(r[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="修改url的某个参数"><a href="#修改url的某个参数" class="headerlink" title="修改url的某个参数"></a>修改url的某个参数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//替换指定传入参数的值,paramName为参数,replaceWith为新值,并跳转</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceParamVal</span>(<span class="params">paramName,replaceWith</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oUrl = <span class="built_in">this</span>.location.href.toString();</span><br><span class="line">    <span class="keyword">var</span> re=<span class="built_in">eval</span>(<span class="string">&#x27;/(&#x27;</span>+ paramName+<span class="string">&#x27;=)([^&amp;]*)/gi&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> nUrl = oUrl.replace(re,paramName+<span class="string">&#x27;=&#x27;</span>+replaceWith);</span><br><span class="line">    <span class="built_in">this</span>.location = nUrl;</span><br><span class="line">　　<span class="built_in">window</span>.location.href=nUrl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如url为：<a href="http://xxxx.cn/pc/meeting/card.html?userId=566&amp;modid=1133&amp;puid=9">http://xxxx.cn/pc/meeting/card.html?userId=566&amp;modid=1133&amp;puid=9</a><br>如果希望修改userId的值为333，那么调用方法：replaceParamVal(“userId”,”333”)<br>URL就会变成：<a href="http://xxx.cn/pc/meeting/card.html?userId=333">http://xxx.cn/pc/meeting/card.html?userId=333</a><br>然后自动跳转到新的url。</p>]]></content>
      
      
      <categories>
          
          <category> 前端相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>form表单提交后重置表单失效解决</title>
      <link href="2021/04/26/web/reset_form_after_submit/"/>
      <url>2021/04/26/web/reset_form_after_submit/</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>页面内提供了数据查询功能，查询字段为姓名和手机号，提交查询请求之后，重置按钮失效；但是在查询之前执行重置的话是可行的。</p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>type=”reset”的input标签，点击后只是重置到默认值，这就很好解释了为什么不点击查询按钮可以重置表单数据为空，<br>而在点击了查询(submit类型)按钮之后，表单各数据内容就等于有值了，所以点击重置不能达到预期重置表单数据为空的目的。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;form&quot;</span>).on(<span class="string">&quot;click&quot;</span>, <span class="string">&quot;button[type=&#x27;reset&#x27;]&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//清空所有type为text的值</span></span><br><span class="line">    <span class="keyword">var</span> $inputs = $(<span class="string">&quot;form&quot;</span>).find(<span class="string">&quot;input[type=&#x27;text&#x27;]&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; $inputs.length;i++)&#123;</span><br><span class="line">        $($inputs[i]).val(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清空select框的值</span></span><br><span class="line">    $(<span class="string">&quot;#channelHtml&quot;</span>).val(<span class="string">&quot;&quot;</span>).trigger(<span class="string">&#x27;change&#x27;</span>);<span class="comment">//下拉框重置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP7新特性简介</title>
      <link href="2021/04/25/php/study/php7_new_features/"/>
      <url>2021/04/25/php/study/php7_new_features/</url>
      
        <content type="html"><![CDATA[<p>PHP7除了在性能方面有极大提升外，还添加了很多新的特性</p><h3 id="太空船操作符"><a href="#太空船操作符" class="headerlink" title="太空船操作符"></a>太空船操作符</h3><p>太空船操作符用于比较两个表达式</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整数</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1</span> &lt;=&gt; <span class="number">1</span>; <span class="comment">//相等时返回0</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1</span> &lt;=&gt; <span class="number">2</span>; <span class="comment">//小于时返回-1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">2</span> &lt;=&gt; <span class="number">1</span>; <span class="comment">//大于时返回1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//浮点数</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1.5</span> &lt;=&gt; <span class="number">1.5</span>; <span class="comment">//相等时返回0</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1.5</span> &lt;=&gt; <span class="number">2.5</span>; <span class="comment">//小于时返回-1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">2.5</span> &lt;=&gt; <span class="number">1.5</span>; <span class="comment">//大于时返回1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;a&#x27;</span> &lt;=&gt; <span class="string">&#x27;a&#x27;</span>; <span class="comment">//相等时返回0</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;a&#x27;</span> &lt;=&gt; <span class="string">&#x27;b&#x27;</span>; <span class="comment">//小于时返回-1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;b&#x27;</span> &lt;=&gt; <span class="string">&#x27;a&#x27;</span>; <span class="comment">//大于时返回1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="标量类型声明和返回值得类型声明"><a href="#标量类型声明和返回值得类型声明" class="headerlink" title="标量类型声明和返回值得类型声明"></a>标量类型声明和返回值得类型声明<br/></h3><h4 id="PHP7可以对参数做声明"><a href="#PHP7可以对参数做声明" class="headerlink" title="PHP7可以对参数做声明"></a>PHP7可以对参数做声明</h4><ul><li>字符串（string）</li><li>整型（int）</li><li>浮点型（float）</li><li>布尔型（bool）</li><li>参数类型前面加上”？”，表示入参或出参值要么是null，要么是声明的类型</li><li>函数的返回类型可以定义void，无论是否声明严格模式，只要函数中有”return;”以外其他的return都会报错<br/> </li><li><font color='red'>注意：入参的参数的类型不能是void</font><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> (strict_types = <span class="number">1</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">?<span class="keyword">int</span> <span class="variable">$a</span></span>) : ?<span class="title">int</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$a</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(test(<span class="literal">null</span>)); <span class="comment">//NULL</span></span><br><span class="line">var_dump(test(<span class="number">1</span>)); <span class="comment">//1</span></span><br><span class="line">var_dump(test(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure><h4 id="PHP7类型声明模式"><a href="#PHP7类型声明模式" class="headerlink" title="PHP7类型声明模式"></a>PHP7类型声明模式</h4></li><li>严格模式：严格模式下，传入的类型和声明的类型不一致会报错</li><li>默认模式：默认模式下，传入的类型和声明的类型不一致会尝试进行类型转换</li><li>模式开启方式<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span>(strict_types = <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="null合并操作符"><a href="#null合并操作符" class="headerlink" title="null合并操作符"></a>null合并操作符</h3>PHP7新的语法糖 “??” ,如果变量存在且值不为null，它返回自身的值，否则返回它的第二个操作数<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$page</span> = <span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>]) ? <span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>] ? <span class="number">0</span>; <span class="comment">//PHP7之前的写法</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$page</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>] ?? <span class="number">0</span>; <span class="comment">//PHP7的写法</span></span><br><span class="line"><span class="variable">$page</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>] ?? <span class="variable">$_POST</span>[<span class="string">&#x27;page&#x27;</span>] ?? <span class="number">0</span>;<span class="comment">//也可以这样写</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="常量数组"><a href="#常量数组" class="headerlink" title="常量数组"></a>常量数组</h3><p>PHP7之前无法通过define来定义数组常量,PHP7支持</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">&#x27;ANIMALS&#x27;</span>,[</span><br><span class="line">    <span class="string">&#x27;dog&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;cat&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;bird&#x27;</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><h3 id="namespace-批量导入"><a href="#namespace-批量导入" class="headerlink" title="namespace 批量导入"></a>namespace 批量导入</h3><p>PHP7之前导入方式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Space</span>\<span class="title">ClassA</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Space</span>\<span class="title">ClassB</span>;</span><br></pre></td></tr></table></figure><p>PHP7之后导入</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Space</span>\&#123;<span class="title">ClassA</span>,<span class="title">ClassB</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="throwable接口"><a href="#throwable接口" class="headerlink" title="throwable接口"></a>throwable接口</h3><p>PHP7之前代码中有语法错误，或者fatal error，程序会直接报错。PHP7中做了改变，<br>PHP7实现了全局throwable接口，原来的Exception和Error实现了该接口，可以被try/catch块捕获。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">undefindfunc();</span><br><span class="line">&#125;<span class="keyword">catch</span> (<span class="built_in">Error</span> <span class="variable">$e</span>)&#123;</span><br><span class="line">var_dump(<span class="variable">$e</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"></span><br><span class="line">set_exception_handler(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$e</span></span>)</span>&#123;</span><br><span class="line">var_dump(<span class="variable">$e</span>);</span><br><span class="line">&#125;);</span><br><span class="line">undefindfunc();</span><br></pre></td></tr></table></figure><h3 id="Closure-call"><a href="#Closure-call" class="headerlink" title="Closure::call()"></a>Closure::call()</h3><p>PHP7之前，需要动态的给一个对象添加方法时，可以通过Closure来复制一个闭包对象，并绑定到一个$this对象和类作用域</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$num</span> = <span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$f</span> = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;num + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable">$test</span> = <span class="variable">$f</span>-&gt;bindTo(<span class="keyword">new</span> Test,<span class="string">&#x27;Test&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$test</span>();</span><br></pre></td></tr></table></figure><p>PHP7中新添加了Closure::call()，可以通过call来暂时绑定一个闭包对象到$this对象，并调用它</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$num</span> = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="variable">$f</span> = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;num + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$f</span>-&gt;call(<span class="keyword">new</span> Test);</span><br></pre></td></tr></table></figure><h3 id="intdiv函数"><a href="#intdiv函数" class="headerlink" title="intdiv函数"></a>intdiv函数</h3><p>PHP7新增一个整除函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var_dump(intdiv(<span class="number">10</span>,<span class="number">3</span>));</span><br></pre></td></tr></table></figure><h3 id="list的方括号写法"><a href="#list的方括号写法" class="headerlink" title="list的方括号写法"></a>list的方括号写法</h3><p>PHP7之前写法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$arr</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">list</span>(<span class="variable">$a</span>,<span class="variable">$b</span>,<span class="variable">$c</span>) = <span class="variable">$arr</span>; </span><br></pre></td></tr></table></figure><p>PHP7优化之后</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$arr</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">[<span class="variable">$a</span>,<span class="variable">$b</span>,<span class="variable">$c</span>] = <span class="variable">$arr</span>;</span><br></pre></td></tr></table></figure><p><font color='red'>注意：这里的[]不是数组的意思，知识list的简略形式</font></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>PHP7除了以上特性外，还有一些其它的，例如：foreach遍历数组时不在修改内部指针、移除了ASP和<br>script PHP标签，移除了$HTTP_RAW_POST_DATA、匿名类、类常量可见性等。</p>]]></content>
      
      
      <categories>
          
          <category> PHP7学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>next不蒜子配置修改</title>
      <link href="2021/04/23/hexo-next/next-busuanzi/"/>
      <url>2021/04/23/hexo-next/next-busuanzi/</url>
      
        <content type="html"><![CDATA[<h2 id="next配置不蒜子统计访问量不生效"><a href="#next配置不蒜子统计访问量不生效" class="headerlink" title="next配置不蒜子统计访问量不生效"></a>next配置不蒜子统计访问量不生效</h2><ul><li>不生效原因，由于<a href="http://busuanzi.ibruce.info/">不蒜子</a>修改域名，next用的还是以前的域名，导致统计引入js脚本报错<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=<span class="string">&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li>修改后引入脚本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=<span class="string">&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> next配置 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/04/21/hello-world/"/>
      <url>2021/04/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
